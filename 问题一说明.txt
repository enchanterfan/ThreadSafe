在ArraiList迭代器中有这么几个参数
cursor：表示下一个要访问的元素的索引，从next()方法的具体实现就可看出
lastRet：表示上一个访问的元素的索引
expectedModCount：表示对ArrayList修改次数的期望值，它的初始值为modCount。
modCount是AbstractList类中的一个成员变量
每次调用add（）或者remove（）方法都会对modCount进行加一操作
但是在执行过程中会导致modCount不等于expectedModCount，则抛出ConcurrentModificationException异常，ArrayList是非线程安全的容器，
且expectedModCount是每个线程私有的，假若此时有2个线程，线程1在进行遍历，线程2在进行remove，
那么很有可能导致线程2修改后导致ArrayList中的modCount自增了，线程2的expectedModCount也自增了，但是线程1的expectedModCount没有自增，
此时线程1遍历时就会出现expectedModCount不等于modCount的情况了，解决方案我采取的是使用使用并发容器CopyOnWriteArrayList代替ArrayList